-- Advanced Instant Interact with UI
if not game:IsLoaded() then game.Loaded:Wait() end

local ProximityPromptService = game:GetService("ProximityPromptService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Settings (you can change these)
local settings = {
    InstantHold = true, -- Set hold duration to 0
    AutoTrigger = false, -- Auto-click when in range
    IncreaseRange = true, -- Increase activation distance
    NoLOS = true, -- No line of sight required
    Keybind = Enum.KeyCode.E, -- Change to your preferred key
    SmartAutoActivate = false, -- Smart auto activation
    SmartActivationRange = 100, -- Range for smart activation
    SmartActivationDelay = 0.3, -- Delay between smart activations
    BypassAllRestrictions = true, -- Bypass all restrictions including cooldowns
    SmartCycleMode = true, -- NEW: Smarter cycle mode - don't repeat until all others done
    ActivateAllNearby = false, -- NEW: Activate ALL nearby prompts every 0.3s
    ActivateAllDelay = 0.3, -- NEW: Delay between activating all nearby prompts
    AutoEngineering = false -- NEW: Auto Engineering feature
}

-- Smart activation variables
local smartActivationRunning = false
local smartActivationThread = nil
local activatedPromptsInCycle = {} -- Track prompts activated in current cycle
local currentCyclePrompts = {} -- All prompts found in current scan
local currentActivationIndex = 1
local lastPromptScan = 0
local promptScanInterval = 0.5 -- Scan for new prompts every 0.5 seconds
local lastActivatedPrompt = nil -- NEW: Track last activated prompt

-- NEW: Activate All Nearby variables
local activateAllRunning = false
local activateAllThread = nil

-- NEW: Auto Engineering variables
local autoEngineeringRunning = false
local autoEngineeringThread = nil
local wireSpoolUses = {} -- Track wire spool uses
local MAX_WIRE_SPOOL_USES = 6 -- Maximum uses before removing
local lastEngineerRemoteTime = 0
local ENGINEER_REMOTE_COOLDOWN = 1 -- Call engineer remote every 1 second
local lastWireSpoolUseTime = 0
local WIRE_SPOOL_COOLDOWN = 1 -- Use wire spools every 1 second

-- Create notification
local function notify(msg)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Instant Interact",
        Text = msg,
        Duration = 3
    })
end

-- Bypass all prompt restrictions
local function bypassPromptRestrictions(prompt)
    if not settings.BypassAllRestrictions then return end
    
    -- Remove all restrictions
    prompt.Enabled = true
    prompt.HoldDuration = 0
    prompt.MaxActivationDistance = 1000 -- Large range
    prompt.RequiresLineOfSight = false
    prompt.ClickablePrompt = true
    
    -- Try to bypass cooldowns by resetting internal timers
    pcall(function()
        for _, prop in pairs({"Cooldown", "CooldownDuration", "Enabled", "Active"}) do
            if prompt[prop] ~= nil then
                if typeof(prompt[prop]) == "number" then
                    prompt[prop] = 0
                elseif typeof(prompt[prop]) == "boolean" then
                    prompt[prop] = true
                end
            end
        end
    end)
end

-- Force activate any prompt regardless of restrictions
local function forceActivatePrompt(prompt)
    bypassPromptRestrictions(prompt)
    fireproximityprompt(prompt)
    
    -- Update last activated prompt
    lastActivatedPrompt = prompt
    
    pcall(function()
        ProximityPromptService:PromptTriggered(prompt, player)
    end)
    
    return true
end

-- Get all prompts within range of player (including disabled ones)
local function getAllNearbyPrompts()
    local character = player.Character
    if not character then return {} end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return {} end
    
    local myPosition = humanoidRootPart.Position
    local allPrompts = {}
    
    -- Scan all descendants including disabled prompts
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            -- Apply bypass to all prompts found
            bypassPromptRestrictions(obj)
            
            -- Check if prompt is within range
            local promptPart = obj.Parent
            local distance = 0
            
            if promptPart and promptPart:IsA("BasePart") then
                distance = (promptPart.Position - myPosition).Magnitude
            end
            
            if distance <= settings.SmartActivationRange or settings.SmartActivationRange == 0 then
                table.insert(allPrompts, {
                    prompt = obj,
                    distance = distance,
                    position = promptPart and promptPart.Position or myPosition,
                    enabled = obj.Enabled
                })
            end
        end
    end
    
    -- Sort by distance (closest first)
    table.sort(allPrompts, function(a, b)
        return a.distance < b.distance
    end)
    
    return allPrompts
end

-- NEW: Auto Engineering Functions - REWORKED
local function findWireSpools()
    local wireSpools = {}
    local character = player.Character
    
    if character then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name:lower()
                if itemName:find("wire") or itemName:find("spool") then
                    table.insert(wireSpools, item)
                end
            end
        end
    end
    
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name:lower()
                if itemName:find("wire") or itemName:find("spool") then
                    table.insert(wireSpools, item)
                end
            end
        end
    end
    
    return wireSpools
end

local function useWireSpools()
    local wireSpools = findWireSpools()
    local usedCount = 0
    
    for _, wireSpool in ipairs(wireSpools) do
        if wireSpool and wireSpool.Parent then
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                -- Equip the wire spool
                humanoid:EquipTool(wireSpool)
                
                -- Use it instantly by clicking
                task.wait(0.05)
                wireSpool:Activate()
                
                -- Track uses
                local toolId = tostring(wireSpool:GetDebugId())
                wireSpoolUses[toolId] = (wireSpoolUses[toolId] or 0) + 1
                
                -- Remove if used 6 times
                if wireSpoolUses[toolId] >= MAX_WIRE_SPOOL_USES then
                    wireSpool:Destroy()
                    wireSpoolUses[toolId] = nil
                    print("Removed wire spool (used " .. MAX_WIRE_SPOOL_USES .. " times)")
                end
                
                usedCount = usedCount + 1
            end
        end
    end
    
    if usedCount > 0 then
        print("Auto Engineering: Used " .. usedCount .. " wire spools")
    end
    
    return usedCount
end

local function callEngineerRemote()
    local currentTime = tick()
    
    -- Try to find and call engineer remote
    local success = false
    
    -- First try through ReplicatedStorage
    local rs = game:GetService("ReplicatedStorage")
    if rs then
        -- Look for RemoteEvents or RemoteFunctions
        for _, remote in ipairs(rs:GetDescendants()) do
            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                local remoteName = remote.Name:lower()
                if remoteName:find("engineer") or remoteName:find("class") or remoteName:find("choose") then
                    pcall(function()
                        remote:FireServer("engineer")
                        print("Called engineer remote: " .. remote.Name)
                        success = true
                    end)
                end
            end
        end
    end
    
    -- Also try through Workspace
    for _, remote in ipairs(workspace:GetDescendants()) do
        if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
            local remoteName = remote.Name:lower()
            if remoteName:find("engineer") or remoteName:find("class") or remoteName:find("choose") then
                pcall(function()
                    remote:FireServer("engineer")
                    print("Called engineer remote: " .. remote.Name)
                    success = true
                end)
            end
        end
    end
    
    if not success then
        -- Try to call selectClass function directly
        pcall(function()
            selectClass("engineer")
            success = true
        end)
    end
    
    return success
end

local function autoEngineeringLoop()
    while settings.AutoEngineering do
        local currentTime = tick()
        
        -- Call engineer remote every second
        if currentTime - lastEngineerRemoteTime >= ENGINEER_REMOTE_COOLDOWN then
            callEngineerRemote()
            lastEngineerRemoteTime = currentTime
        end
        
        -- Use wire spools every second
        if currentTime - lastWireSpoolUseTime >= WIRE_SPOOL_COOLDOWN then
            useWireSpools()
            lastWireSpoolUseTime = currentTime
        end
        
        task.wait(0.1) -- Small delay to prevent lag
    end
end

local function toggleAutoEngineering(state)
    settings.AutoEngineering = state
    _G.AutoEngineering = state
    
    if state then
        -- Reset wire spool tracking
        wireSpoolUses = {}
        lastEngineerRemoteTime = 0
        lastWireSpoolUseTime = 0
        
        -- Start the auto engineering loop
        autoEngineeringThread = task.spawn(function()
            autoEngineeringLoop()
        end)
        
        notify("Auto Engineering: ON\nUsing engineer remote and wire spools every second")
    else
        -- Stop the auto engineering loop
        if autoEngineeringThread then
            task.cancel(autoEngineeringThread)
            autoEngineeringThread = nil
        end
        
        notify("Auto Engineering: OFF")
    end
end

-- NEW: Activate ALL nearby prompts instantly every 0.3s
local function activateAllNearbyPrompts()
    if not settings.ActivateAllNearby then return end
    
    local allPrompts = getAllNearbyPrompts()
    local activatedCount = 0
    
    for _, promptData in ipairs(allPrompts) do
        forceActivatePrompt(promptData.prompt)
        activatedCount = activatedCount + 1
    end
    
    if activatedCount > 0 then
        print("Activated ALL " .. activatedCount .. " nearby prompts (0.3s loop)")
    end
end

-- Start/stop the Activate All Nearby loop
local function toggleActivateAllNearby(state)
    settings.ActivateAllNearby = state
    _G.ActivateAllNearby = state
    
    if state then
        -- Turn off SmartAutoActivate if it's on
        if settings.SmartAutoActivate then
            toggleSmartActivation(false)
        end
        
        activateAllRunning = true
        
        -- Start the loop
        activateAllThread = game:GetService("RunService").Heartbeat:Connect(function()
            activateAllNearbyPrompts()
            wait(settings.ActivateAllDelay)
        end)
        
        notify("Activate ALL Nearby: ON\nActivating every prompt in range every " .. settings.ActivateAllDelay .. "s")
    else
        activateAllRunning = false
        if activateAllThread then
            activateAllThread:Disconnect()
            activateAllThread = nil
        end
        notify("Activate ALL Nearby: OFF")
    end
end

-- Ultra-smart activation system - activates each prompt once, doesn't repeat until all others done
local function ultraSmartActivatePrompts()
    if not settings.SmartAutoActivate then return end
    
    -- Scan for all prompts (including disabled ones)
    local currentTime = tick()
    if currentTime - lastPromptScan > promptScanInterval then
        local allPrompts = getAllNearbyPrompts()
        lastPromptScan = currentTime
        
        -- Update cycle if prompts have changed
        local cycleChanged = false
        if #currentCyclePrompts ~= #allPrompts then
            cycleChanged = true
        else
            for i, promptData in ipairs(allPrompts) do
                local oldPrompt = currentCyclePrompts[i]
                if not oldPrompt or promptData.prompt ~= oldPrompt.prompt then
                    cycleChanged = true
                    break
                end
            end
        end
        
        if cycleChanged then
            currentCyclePrompts = allPrompts
            activatedPromptsInCycle = {}
            currentActivationIndex = 1
            lastActivatedPrompt = nil
            print("Ultra-smart mode: " .. #allPrompts .. " prompts found")
        end
    end
    
    if #currentCyclePrompts == 0 then
        return
    end
    
    -- SMART CYCLE LOGIC: Find next prompt that hasn't been activated yet
    -- Start from current activation index and wrap around
    local foundPrompt = nil
    local startIndex = currentActivationIndex
    
    for i = 1, #currentCyclePrompts do
        local index = ((startIndex + i - 2) % #currentCyclePrompts) + 1
        local promptData = currentCyclePrompts[index]
        local promptId = tostring(promptData.prompt:GetDebugId())
        
        -- Check if this prompt is different from the last activated one AND hasn't been activated in this cycle
        if promptData.prompt ~= lastActivatedPrompt and not activatedPromptsInCycle[promptId] then
            foundPrompt = promptData.prompt
            currentActivationIndex = index + 1
            if currentActivationIndex > #currentCyclePrompts then
                currentActivationIndex = 1
            end
            activatedPromptsInCycle[promptId] = true
            break
        end
    end
    
    -- If all prompts have been activated in this cycle, check cycle status
    if not foundPrompt then
        -- Check how many prompts have been activated
        local activatedCount = 0
        for _ in pairs(activatedPromptsInCycle) do
            activatedCount = activatedCount + 1
        end
        
        if activatedCount >= #currentCyclePrompts then
            -- All prompts have been activated at least once in this cycle
            print("ULTRA-SMART CYCLE COMPLETE: All " .. #currentCyclePrompts .. " prompts activated at least once")
            
            -- Reset cycle but keep track for next round
            activatedPromptsInCycle = {}
            
            -- Start with a different prompt than last time
            if #currentCyclePrompts > 1 then
                for i = 1, #currentCyclePrompts do
                    local promptData = currentCyclePrompts[i]
                    if promptData.prompt ~= lastActivatedPrompt then
                        foundPrompt = promptData.prompt
                        local promptId = tostring(foundPrompt:GetDebugId())
                        activatedPromptsInCycle[promptId] = true
                        currentActivationIndex = i + 1
                        if currentActivationIndex > #currentCyclePrompts then
                            currentActivationIndex = 1
                        end
                        break
                    end
                end
            else
                -- Only one prompt, just activate it again
                foundPrompt = currentCyclePrompts[1].prompt
                local promptId = tostring(foundPrompt:GetDebugId())
                activatedPromptsInCycle[promptId] = true
            end
        else
            -- Some prompts haven't been activated yet, but we're stuck
            -- Reset activation tracking to try again
            activatedPromptsInCycle = {}
            currentActivationIndex = 1
            foundPrompt = currentCyclePrompts[1].prompt
            local promptId = tostring(foundPrompt:GetDebugId())
            activatedPromptsInCycle[promptId] = true
            print("Cycle stuck, resetting...")
        end
    end
    
    -- Force activate the prompt
    if foundPrompt then
        forceActivatePrompt(foundPrompt)
        local activatedCount = 0
        for _ in pairs(activatedPromptsInCycle) do
            activatedCount = activatedCount + 1
        end
        print("Ultra-smart activated [" .. activatedCount .. "/" .. #currentCyclePrompts .. "]: " .. foundPrompt.Name)
    end
end

-- Start/stop smart activation
local function toggleSmartActivation(state)
    settings.SmartAutoActivate = state
    _G.SmartAutoActivate = state
    
    if state then
        -- Turn off ActivateAllNearby if it's on
        if settings.ActivateAllNearby then
            toggleActivateAllNearby(false)
        end
        
        smartActivationRunning = true
        
        smartActivationThread = game:GetService("RunService").Heartbeat:Connect(function()
            ultraSmartActivatePrompts() -- Use ultra-smart version
            wait(settings.SmartActivationDelay)
        end)
        
        notify("Ultra-Smart Activation: ON\nActivating ALL prompts in smart cycle")
    else
        smartActivationRunning = false
        if smartActivationThread then
            smartActivationThread:Disconnect()
            smartActivationThread = nil
        end
        activatedPromptsInCycle = {}
        currentCyclePrompts = {}
        currentActivationIndex = 1
        lastActivatedPrompt = nil
        notify("Smart Activation: OFF")
    end
end

-- Manual activation of ALL nearby prompts (force bypass)
local function manualActivateAllPrompts()
    local allPrompts = getAllNearbyPrompts()
    local activatedCount = 0
    
    for _, promptData in ipairs(allPrompts) do
        forceActivatePrompt(promptData.prompt)
        activatedCount = activatedCount + 1
    end
    
    notify("Force activated " .. activatedCount .. " prompts (bypassed all restrictions)")
    print("Force activation: Activated " .. activatedCount .. " prompts (bypassed cooldowns)")
end

-- Reset smart activation tracking
local function resetSmartActivation()
    activatedPromptsInCycle = {}
    currentCyclePrompts = {}
    currentActivationIndex = 1
    lastActivatedPrompt = nil
    print("Smart activation tracking reset")
    notify("Smart activation tracking reset")
end

-- Continuous prompt enhancer (runs in background)
local function startPromptEnhancer()
    spawn(function()
        while true do
            -- Apply bypass to ALL prompts in workspace
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("ProximityPrompt") then
                    bypassPromptRestrictions(obj)
                end
            end
            
            wait(1) -- Check every second
        end
    end)
end

-- Main function
local function setupInstantPrompts()
    -- Process existing prompts
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            bypassPromptRestrictions(obj)
        end
    end
    
    -- Process new prompts
    workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("ProximityPrompt") then
            bypassPromptRestrictions(obj)
        end
    end)
    
    -- Instant trigger
    ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
        forceActivatePrompt(prompt)
    end)
    
    -- Auto-trigger (if enabled)
    if settings.AutoTrigger then
        ProximityPromptService.PromptShown:Connect(function(prompt)
            task.wait(0.1)
            forceActivatePrompt(prompt)
        end)
    end
    
    -- Keybind to trigger all nearby prompts
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == settings.Keybind then
            manualActivateAllPrompts()
        end
    end)
    
    -- Start background prompt enhancer
    startPromptEnhancer()
end

-- Execute
setupInstantPrompts()
notify("ULTIMATE SMART PROMPT ACTIVATOR LOADED!\nBypassing ALL restrictions")

print([[

╔══════════════════════════════════════════════╗
║      ULTRA-SMART PROMPT ACTIVATOR LOADED     ║
║  • Bypasses ALL restrictions                 ║
║  • Ultra-smart cycle activation              ║
║  • No repeat until all others activated      ║
║  • Works on disabled prompts                 ║
║  • Activate ALL nearby every 0.3s            ║
║  • Auto Engineering feature REWORKED         ║
╚══════════════════════════════════════════════╝
]])

-- Services
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Settings
_G.NPCHeadSize = 100
_G.Disabled = false
_G.NPCEnabled = true
_G.ESPEnabled = false
_G.AimbotEnabled = false
_G.HitboxAllEnabled = false
_G.AimbotFOV = 100
_G.AimbotSmoothness = 0.3
_G.AimbotWallCheck = false
_G.AimbotAutoShoot = false
_G.AimbotMaxDistance = 500
_G.AutoCookBread = false
_G.AutoCookDelay = 0.3
-- Auto Throw Grenade Settings
_G.AutoThrowGrenade = false
_G.AutoThrowDelay = 0.1
-- Ultimate Prompt Activation Settings
_G.SmartAutoActivate = settings.SmartAutoActivate
_G.SmartActivationRange = settings.SmartActivationRange
_G.SmartActivationDelay = settings.SmartActivationDelay
_G.BypassAllRestrictions = settings.BypassAllRestrictions
_G.SmartCycleMode = settings.SmartCycleMode
_G.ActivateAllNearby = settings.ActivateAllNearby
_G.ActivateAllDelay = settings.ActivateAllDelay
-- Auto Engineering Settings
_G.AutoEngineering = settings.AutoEngineering

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local TrackedNPCs = {}
local ESPInstances = {}
local HeadScaleInstances = {}
local currentTarget = nil
local isRunning = false
local cooking = false
local throwingGrenade = false
local lastThrowTime = 0

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "WhizzbangGUI"
ScreenGui.Parent = CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- NPC Detection
local function isNPC(model)
    if not model or not model:IsA("Model") then return false end
    if model.Name:lower():find("prop") then return false end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character == model then
            return false
        end
    end
    
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    return true
end

-- Simple head scaling (VISUAL ONLY - Client Side)
local function scaleNPCHead(npc, scaleMultiplier)
    if not npc or not npc.Parent then return end
    
    local head = npc:FindFirstChild("Head")
    if not head then return end
    
    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    -- Store original if not already stored
    if not HeadScaleInstances[npc] then
        local mesh = head:FindFirstChildOfClass("SpecialMesh")
        HeadScaleInstances[npc] = {
            OriginalSize = head.Size,
            OriginalMeshScale = mesh and mesh.Scale or Vector3.new(1, 1, 1),
            Mesh = mesh,
            OriginalCFrame = head.CFrame
        }
    end
    
    -- Apply visual scaling (client-side only)
    local data = HeadScaleInstances[npc]
    local scaleValue = scaleMultiplier / 100
    
    -- Create visual overlay if it doesn't exist
    if not data.VisualOverlay then
        local overlay = Instance.new("Part")
        overlay.Name = "HitboxOverlay"
        overlay.Size = head.Size * scaleValue
        overlay.Shape = Enum.PartType.Ball
        overlay.Transparency = 0.7
        overlay.Color = Color3.fromRGB(255, 50, 50)
        overlay.Material = Enum.Material.Neon
        overlay.CanCollide = false
        overlay.Anchored = true
        overlay.CanQuery = false
        overlay.Parent = npc
        
        data.VisualOverlay = overlay
    end
    
    -- Update overlay size and position
    local overlay = data.VisualOverlay
    overlay.Size = head.Size * scaleValue
    overlay.CFrame = head.CFrame
    
    -- Update the actual head mesh for visual consistency
    if data.Mesh and data.Mesh.Parent == head then
        data.Mesh.Scale = data.OriginalMeshScale * scaleValue
    else
        head.Size = data.OriginalSize * scaleValue
    end
end

local function resetNPCHead(npc)
    if HeadScaleInstances[npc] then
        local head = npc:FindFirstChild("Head")
        if head then
            local data = HeadScaleInstances[npc]
            if data.Mesh and data.Mesh.Parent == head then
                data.Mesh.Scale = data.OriginalMeshScale
            else
                head.Size = data.OriginalSize
            end
        end
        if HeadScaleInstances[npc].VisualOverlay then
            HeadScaleInstances[npc].VisualOverlay:Destroy()
        end
        HeadScaleInstances[npc] = nil
    end
end

local function resetAllHeadScales()
    for npc, _ in pairs(HeadScaleInstances) do
        resetNPCHead(npc)
    end
    HeadScaleInstances = {}
end

-- Simple Compact ESP
local function createESP(npc)
    if ESPInstances[npc] then return end
    
    local espContainer = Instance.new("Frame")
    espContainer.Name = "ESP_" .. npc.Name
    espContainer.BackgroundTransparency = 1
    espContainer.Size = UDim2.new(0, 40, 0, 12)
    espContainer.Visible = false
    espContainer.ZIndex = 999
    ESPInstances[npc] = espContainer
    
    -- Small health bar
    local healthBar = Instance.new("Frame")
    healthBar.Name = "HealthBar"
    healthBar.Size = UDim2.new(1, 0, 0.5, 0)
    healthBar.Position = UDim2.new(0, 0, 0.5, 0)
    healthBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    healthBar.BackgroundTransparency = 0.3
    healthBar.BorderSizePixel = 0
    healthBar.ZIndex = 1000
    healthBar.Parent = espContainer
    
    local healthFill = Instance.new("Frame")
    healthFill.Name = "HealthFill"
    healthFill.Size = UDim2.new(1, 0, 1, 0)
    healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    healthFill.BackgroundTransparency = 0.2
    healthFill.BorderSizePixel = 0
    healthFill.ZIndex = 1001
    healthFill.Parent = healthBar
    
    -- Health text
    local healthText = Instance.new("TextLabel")
    healthText.Name = "HealthText"
    healthText.Size = UDim2.new(1, 0, 0.5, 0)
    healthText.Position = UDim2.new(0, 0, 0, 0)
    healthText.BackgroundTransparency = 1
    healthText.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthText.TextSize = 8
    healthText.Font = Enum.Font.Gotham
    healthText.TextStrokeTransparency = 0.7
    healthText.ZIndex = 1000
    healthText.Parent = espContainer
    
    espContainer.Parent = ScreenGui
end

local function removeESP(npc)
    if ESPInstances[npc] then
        ESPInstances[npc]:Destroy()
        ESPInstances[npc] = nil
    end
end

local function updateESP()
    if not _G.ESPEnabled then return end
    
    for npc, esp in pairs(ESPInstances) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local screenPoint, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 2, 0))
                
                if onScreen then
                    esp.Position = UDim2.new(0, screenPoint.X - 20, 0, screenPoint.Y - 6)
                    esp.Visible = true
                    
                    -- Update health
                    local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                    local healthFill = esp:FindFirstChild("HealthBar"):FindFirstChild("HealthFill")
                    local healthText = esp:FindFirstChild("HealthText")
                    
                    if healthFill then
                        healthFill.Size = UDim2.new(healthPercent, 0, 1, 0)
                        
                        -- Color based on health
                        if healthPercent > 0.6 then
                            healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                        elseif healthPercent > 0.3 then
                            healthFill.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
                        else
                            healthFill.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                        end
                    end
                    
                    if healthText then
                        healthText.Text = math.floor(humanoid.Health)
                    end
                else
                    esp.Visible = false
                end
            else
                removeESP(npc)
            end
        else
            removeESP(npc)
        end
    end
end

-- Get closest NPC for grenade throwing
local function getClosestNPCForGrenade()
    local closest = nil
    local closestDistance = math.huge
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    local myPosition = humanoidRootPart.Position
    
    for npc, _ in pairs(TrackedNPCs) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local distance = (head.Position - myPosition).Magnitude
                
                if distance < closestDistance then
                    closestDistance = distance
                    closest = npc
                end
            end
        end
    end
    
    return closest
end

-- Clean inventory for auto-throw (KEEP mill, ornamlll, and essential items)
local function cleanInventoryForThrow()
    local character = LocalPlayer.Character
    if not character then return end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name:lower()
                -- Keep grenades and essential items
                if itemName ~= "mill" and itemName ~= "ornamlll" and itemName ~= "wire spool" then
                    item:Destroy()
                end
            end
        end
    end
    
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            local itemName = item.Name:lower()
            if itemName ~= "mill" and itemName ~= "ornamlll" and itemName ~= "wire spool" then
                item:Destroy()
            end
        end
    end
end

-- Simple Aimbot
local function getClosestNPC()
    local closest = nil
    local closestDistance = math.huge
    local cameraPos = Camera.CFrame.Position
    
    for npc, _ in pairs(TrackedNPCs) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local distance = (head.Position - cameraPos).Magnitude
                if distance > _G.AimbotMaxDistance then continue end
                
                local screenPoint, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    local pointVector = Vector2.new(screenPoint.X, screenPoint.Y)
                    local distanceFromCenter = (pointVector - screenCenter).Magnitude
                    local fovRadius = (_G.AimbotFOV / 100) * math.min(Camera.ViewportSize.X, Camera.ViewportSize.Y) / 2
                    
                    if distanceFromCenter <= fovRadius and distance < closestDistance then
                        closestDistance = distance
                        closest = npc
                    end
                end
            end
        end
    end
    
    return closest
end

local function smoothAim(targetPosition)
    local currentCF = Camera.CFrame
    local currentPos = currentCF.Position
    
    local lookVector = (targetPosition - currentPos).Unit
    local currentLook = currentCF.LookVector
    
    local newLook = currentLook:Lerp(lookVector, _G.AimbotSmoothness)
    Camera.CFrame = CFrame.new(currentPos, currentPos + newLook)
end

-- Auto Throw Grenade Function (UPDATED for both mill and ornamlll)
local function autoThrowGrenade()
    if not _G.AutoThrowGrenade then return end
    if throwingGrenade then return end
    
    local currentTime = tick()
    if currentTime - lastThrowTime < _G.AutoThrowDelay then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    local targetNPC = getClosestNPCForGrenade()
    if not targetNPC then return end
    
    local targetHead = targetNPC:FindFirstChild("Head")
    if not targetHead then return end
    
    throwingGrenade = true
    
    cleanInventoryForThrow()
    
    -- Select rifleman class for grenades
    pcall(function()
        local remotePath = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("Player"):WaitForChild("ChooseClass")
        remotePath:FireServer("rifle", "rifleman")
    end)
    
    wait(0.05)
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local grenadeTool = nil
    
    -- Look for grenades (PRIORITIZE ornamlll, then mill)
    if backpack then
        -- First try to find ornamlll
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "ornamlll" then
                grenadeTool = item
                break
            end
        end
        -- If no ornamlll, look for mill
        if not grenadeTool then
            for _, item in ipairs(backpack:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "mill" then
                    grenadeTool = item
                    break
                end
            end
        end
    end
    
    if not grenadeTool then
        -- Check character for ornamlll
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "ornamlll" then
                grenadeTool = item
                break
            end
        end
        -- Check character for mill
        if not grenadeTool then
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == "mill" then
                    grenadeTool = item
                    break
                end
            end
        end
    end
    
    if grenadeTool then
        humanoid:EquipTool(grenadeTool)
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local targetPosition = targetHead.Position + Vector3.new(0, 5, 0)
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
        end
        
        wait(0.05)
        grenadeTool:Activate()
        wait(0.05)
        
        print("Auto-threw " .. grenadeTool.Name .. " at enemy: " .. targetNPC.Name)
        lastThrowTime = currentTime
    else
        -- Request grenades (try both types)
        pcall(function()
            local grenadeRemote = ReplicatedStorage:FindFirstChild("RemoteEvents"):FindFirstChild("GetGrenade")
            if grenadeRemote then
                grenadeRemote:FireServer()
                print("Requested grenade via GetGrenade remote")
            end
        end)
        
        pcall(function()
            local ornamlllRemote = ReplicatedStorage:FindFirstChild("RemoteEvents"):FindFirstChild("GetOrnamlll")
            if ornamlllRemote then
                ornamlllRemote:FireServer()
                print("Requested ornamlll via GetOrnamlll remote")
            end
        end)
        
        print("No grenades found, requesting more...")
    end
    
    throwingGrenade = false
end

-- Start auto throw grenade loop
local function startAutoThrow()
    spawn(function()
        while _G.AutoThrowGrenade do
            autoThrowGrenade()
            wait(0.05)
        end
    end)
end

-- Main Game Loop
local function mainLoop()
    if _G.Disabled or not _G.NPCEnabled then
        for npc, _ in pairs(TrackedNPCs) do
            removeESP(npc)
            resetNPCHead(npc)
        end
        TrackedNPCs = {}
        ESPInstances = {}
        HeadScaleInstances = {}
        currentTarget = nil
        return
    end
    
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA("Model") and not TrackedNPCs[model] then
            if isNPC(model) then
                TrackedNPCs[model] = true
                
                if _G.ESPEnabled then
                    createESP(model)
                end
                
                if _G.HitboxAllEnabled then
                    scaleNPCHead(model, _G.NPCHeadSize)
                end
            end
        end
    end
    
    for npc, _ in pairs(TrackedNPCs) do
        if not npc.Parent or not isNPC(npc) then
            TrackedNPCs[npc] = nil
            removeESP(npc)
            resetNPCHead(npc)
        end
    end
    
    updateESP()
    
    -- Update visual overlays for hitboxes
    if _G.HitboxAllEnabled then
        for npc, data in pairs(HeadScaleInstances) do
            if npc and npc.Parent and data.VisualOverlay then
                local head = npc:FindFirstChild("Head")
                if head then
                    data.VisualOverlay.CFrame = head.CFrame
                end
            end
        end
    end
    
    if _G.AimbotEnabled and LocalPlayer.Character then
        local targetNPC = getClosestNPC()
        
        if targetNPC then
            local head = targetNPC:FindFirstChild("Head")
            if head then
                smoothAim(head.Position)
                
                if _G.AimbotAutoShoot then
                    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    if tool then
                        for _, v in ipairs(tool:GetDescendants()) do
                            if v:IsA("RemoteEvent") then
                                pcall(function() v:FireServer() end)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Bread Cooking
local function cookBread()
    pcall(function()
        local breadFolder = ReplicatedStorage:FindFirstChild("Bread")
        if breadFolder then
            local kneadRemote = breadFolder:FindFirstChild("KneadBread")
            local cookRemote = breadFolder:FindFirstChild("CookRaw")
            
            if kneadRemote then
                kneadRemote:FireServer("stale bred")
            end
            
            if cookRemote then
                cookRemote:FireServer(10)
            end
        end
    end)
end

local function startAutoCook()
    if cooking then return end
    cooking = true
    
    spawn(function()
        while _G.AutoCookBread do
            cookBread()
            wait(_G.AutoCookDelay)
        end
        cooking = false
    end)
end

-- Class Selection with Inventory Management
local function cleanupInventory(keepItemName)
    local character = LocalPlayer.Character
    if not character then return end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name:lower()
                local keepName = keepItemName:lower()
                
                -- Special handling for rifleman: keep both mill and ornamlll
                if keepName == "mill" then
                    if itemName ~= "mill" and itemName ~= "ornamlll" and itemName ~= "wire spool" then
                        item:Destroy()
                        print("Deleted non-grenade item from backpack: " .. item.Name)
                    else
                        print("Kept in backpack: " .. item.Name)
                    end
                elseif keepName == "ornamlll" then
                    -- This handles special ornamlll requests
                    if itemName ~= "ornamlll" and itemName ~= "mill" then
                        item:Destroy()
                    end
                else
                    if itemName ~= keepName then
                        item:Destroy()
                        print("Deleted item from backpack: " .. item.Name)
                    else
                        print("Kept item in backpack: " .. item.Name)
                    end
                end
            end
        end
    end
    
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            local itemName = item.Name:lower()
            local keepName = keepItemName:lower()
            
            -- Special handling for rifleman: keep both mill and ornamlll
            if keepName == "mill" then
                if itemName ~= "mill" and itemName ~= "ornamlll" and itemName ~= "wire spool" then
                    item:Destroy()
                    print("Deleted non-grenade item from character: " .. item.Name)
                else
                    print("Kept on character: " .. item.Name)
                end
            elseif keepName == "ornamlll" then
                -- This handles special ornamlll requests
                if itemName ~= "ornamlll" and itemName ~= "mill" then
                    item:Destroy()
                end
            else
                if itemName ~= keepName then
                    item:Destroy()
                    print("Deleted item from character: " .. item.Name)
                else
                    print("Kept item on character: " .. item.Name)
                end
            end
        end
    end
end

local function selectClass(classType)
    pcall(function()
        local remotePath = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("Player"):WaitForChild("ChooseClass")
        local args = {}
        
        if classType == "medic" then
            args = {"medic", "medic"}
        elseif classType == "engineer" then
            args = {"engi", "engineer"}
        elseif classType == "rifleman" then
            args = {"rifle", "rifleman"}
        elseif classType == "officer" then
            args = {"officer", "officer"}
        elseif classType == "machinegun" then
            args = {"auto", "automatic"}
        end
        
        remotePath:FireServer(unpack(args))
        
        wait(0.5)
        
        if classType == "rifleman" then
            cleanupInventory("mill") -- This will keep both mill and ornamlll
            print("Selected Rifleman - keeping mill and ornamlll grenades")
            
            -- Also try to get ornamlll grenade via remote
            pcall(function()
                wait(0.2)
                local ornamlllRemote = ReplicatedStorage:FindFirstChild("RemoteEvents"):FindFirstChild("GetOrnamlll")
                if ornamlllRemote then
                    ornamlllRemote:FireServer()
                    print("Requested ornamlll grenade after selecting rifleman")
                end
            end)
        elseif classType == "engineer" then
            cleanupInventory("wire spool")
        end
    end)
end

-- Function to manually equip and throw ornamlll
local function manualThrowOrnamlll()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    local targetNPC = getClosestNPCForGrenade()
    if not targetNPC then 
        notify("No NPCs found to throw grenade at!")
        return 
    end
    
    local targetHead = targetNPC:FindFirstChild("Head")
    if not targetHead then return end
    
    -- Look for ornamlll in inventory
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local ornamlllTool = nil
    
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "ornamlll" then
                ornamlllTool = item
                break
            end
        end
    end
    
    if not ornamlllTool then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "ornamlll" then
                ornamlllTool = item
                break
            end
        end
    end
    
    if ornamlllTool then
        humanoid:EquipTool(ornamlllTool)
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local targetPosition = targetHead.Position + Vector3.new(0, 5, 0)
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
        end
        
        wait(0.1)
        ornamlllTool:Activate()
        
        notify("Threw ornamlll at enemy: " .. targetNPC.Name)
        print("Manual throw: Threw ornamlll at " .. targetNPC.Name)
    else
        -- Try to get ornamlll
        pcall(function()
            local ornamlllRemote = ReplicatedStorage:FindFirstChild("RemoteEvents"):FindFirstChild("GetOrnamlll")
            if ornamlllRemote then
                ornamlllRemote:FireServer()
                notify("No ornamlll found, requesting one...")
            else
                notify("No ornamlll found and no remote available!")
            end
        end)
    end
end

-- GUI SETUP
local function createToggleButton(label, default, callback)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, 30)
    container.BackgroundTransparency = 1
    
    local labelText = Instance.new("TextLabel")
    labelText.Size = UDim2.new(0.7, 0, 1, 0)
    labelText.BackgroundTransparency = 1
    labelText.Text = label
    labelText.TextColor3 = Color3.fromRGB(220, 220, 220)
    labelText.Font = Enum.Font.GothamMedium
    labelText.TextSize = 12
    labelText.TextXAlignment = Enum.TextXAlignment.Left
    labelText.Parent = container
    
    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0.25, 0, 0.7, 0)
    toggleButton.Position = UDim2.new(0.75, 0, 0.15, 0)
    toggleButton.BackgroundColor3 = default and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
    toggleButton.Text = default and "ON" or "OFF"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 11
    toggleButton.Parent = container
    
    local state = default
    
    toggleButton.MouseButton1Click:Connect(function()
        state = not state
        toggleButton.BackgroundColor3 = state and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
        toggleButton.Text = state and "ON" or "OFF"
        callback(state)
    end)
    
    return container, function(newState)
        state = newState
        toggleButton.BackgroundColor3 = state and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
        toggleButton.Text = state and "ON" or "OFF"
        callback(state)
    end
end

local function createNumberInput(label, min, max, default, callback)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, 50)
    container.BackgroundTransparency = 1
    
    local labelText = Instance.new("TextLabel")
    labelText.Size = UDim2.new(1, 0, 0, 20)
    labelText.BackgroundTransparency = 1
    labelText.Text = label
    labelText.TextColor3 = Color3.fromRGB(200, 200, 200)
    labelText.Font = Enum.Font.GothamMedium
    labelText.TextSize = 12
    labelText.TextXAlignment = Enum.TextXAlignment.Left
    labelText.Parent = container
    
    local textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(1, 0, 0, 25)
    textBox.Position = UDim2.new(0, 0, 0, 20)
    textBox.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    textBox.Text = tostring(default)
    textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    textBox.Font = Enum.Font.Gotham
    textBox.TextSize = 12
    textBox.TextXAlignment = Enum.TextXAlignment.Center
    textBox.ClearTextOnFocus = false
    textBox.Parent = container
    
    textBox.FocusLost:Connect(function()
        local num = tonumber(textBox.Text)
        if num then
            num = math.clamp(num, min, max)
            textBox.Text = tostring(num)
            callback(num)
        else
            textBox.Text = tostring(default)
        end
    end)
    
    return container
end

-- Main GUI Frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 320, 0, 750)
MainFrame.Position = UDim2.new(1, -340, 0.5, -375)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
MainFrame.BackgroundTransparency = 0.05
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false
MainFrame.Parent = ScreenGui

-- Title Bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 30)
TitleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -40, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "ULTRA-SMART PROMPT ACTIVATOR"
Title.TextColor3 = Color3.fromRGB(255, 100, 100)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 14
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TitleBar

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 25, 0, 25)
CloseButton.Position = UDim2.new(1, -30, 0.5, -12.5)
CloseButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
CloseButton.Text = "✕"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 14
CloseButton.Parent = TitleBar

-- Content Frame
local ContentFrame = Instance.new("Frame")
ContentFrame.Size = UDim2.new(1, -20, 1, -40)
ContentFrame.Position = UDim2.new(0, 10, 0, 35)
ContentFrame.BackgroundTransparency = 1
ContentFrame.Parent = MainFrame

-- Use a ScrollingFrame to ensure everything fits
local ScrollFrame = Instance.new("ScrollingFrame")
ScrollFrame.Size = UDim2.new(1, 0, 1, 0)
ScrollFrame.BackgroundTransparency = 1
ScrollFrame.ScrollBarThickness = 8
ScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 1250)
ScrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
ScrollFrame.Parent = ContentFrame

local UIListLayout = Instance.new("UIListLayout")
UIListLayout.Padding = UDim.new(0, 10)
UIListLayout.Parent = ScrollFrame

-- Store update functions
local toggleUpdateFunctions = {}

-- ULTRA-SMART PROMPT ACTIVATION SECTION
local promptSection = Instance.new("Frame")
promptSection.Size = UDim2.new(1, 0, 0, 260)
promptSection.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
promptSection.Parent = ScrollFrame

local promptTitle = Instance.new("TextLabel")
promptTitle.Size = UDim2.new(1, -10, 0, 20)
promptTitle.Position = UDim2.new(0, 5, 0, 5)
promptTitle.BackgroundTransparency = 1
promptTitle.Text = "ULTRA-SMART PROMPT ACTIVATOR"
promptTitle.TextColor3 = Color3.fromRGB(255, 100, 100)
promptTitle.Font = Enum.Font.GothamBold
promptTitle.TextSize = 12
promptTitle.TextXAlignment = Enum.TextXAlignment.Left
promptTitle.Parent = promptSection

local promptInfo = Instance.new("TextLabel")
promptInfo.Size = UDim2.new(1, -10, 0, 40)
promptInfo.Position = UDim2.new(0, 5, 0, 25)
promptInfo.BackgroundTransparency = 1
promptInfo.Text = "Smart cycle: No repeat until all others activated\nBypasses ALL restrictions\nActivate ALL: Fires every prompt in range"
promptInfo.TextColor3 = Color3.fromRGB(200, 150, 150)
promptInfo.Font = Enum.Font.Gotham
promptInfo.TextSize = 10
promptInfo.TextXAlignment = Enum.TextXAlignment.Left
promptInfo.TextYAlignment = Enum.TextYAlignment.Top
promptInfo.Parent = promptSection

-- Bypass Restrictions Toggle
local bypassToggle, updateBypassToggle = createToggleButton("Bypass All Restrictions", _G.BypassAllRestrictions, function(value)
    _G.BypassAllRestrictions = value
    settings.BypassAllRestrictions = value
end)
bypassToggle.Size = UDim2.new(1, -10, 0, 30)
bypassToggle.Position = UDim2.new(0, 5, 0, 70)
bypassToggle.Parent = promptSection

-- Smart Activation Toggle
local smartToggle, updateSmartToggle = createToggleButton("Ultra-Smart Auto Activate", _G.SmartAutoActivate, function(value)
    toggleSmartActivation(value)
end)
smartToggle.Size = UDim2.new(1, -10, 0, 30)
smartToggle.Position = UDim2.new(0, 5, 0, 105)
smartToggle.Parent = promptSection

-- NEW: Activate ALL Nearby Toggle (every 0.3s)
local activateAllToggle, updateActivateAllToggle = createToggleButton("ACTIVATE ALL NEARBY (0.3s)", _G.ActivateAllNearby, function(value)
    toggleActivateAllNearby(value)
end)
activateAllToggle.Size = UDim2.new(1, -10, 0, 30)
activateAllToggle.Position = UDim2.new(0, 5, 0, 140)
activateAllToggle.Parent = promptSection

-- NEW: Auto Engineering Toggle
local autoEngineeringToggle, updateAutoEngineeringToggle = createToggleButton("AUTO ENGINEERING (1s)", _G.AutoEngineering, function(value)
    toggleAutoEngineering(value)
end)
autoEngineeringToggle.Size = UDim2.new(1, -10, 0, 30)
autoEngineeringToggle.Position = UDim2.new(0, 5, 0, 175)
autoEngineeringToggle.Parent = promptSection

-- Smart Cycle Mode Toggle
local smartCycleToggle, updateSmartCycleToggle = createToggleButton("Smart Cycle Mode", _G.SmartCycleMode, function(value)
    _G.SmartCycleMode = value
    settings.SmartCycleMode = value
end)
smartCycleToggle.Size = UDim2.new(1, -10, 0, 30)
smartCycleToggle.Position = UDim2.new(0, 5, 0, 210)
smartCycleToggle.Parent = promptSection

-- Create a container for range and delay inputs
local inputRow1 = Instance.new("Frame")
inputRow1.Size = UDim2.new(1, -10, 0, 25)
inputRow1.Position = UDim2.new(0, 5, 0, 245)
inputRow1.BackgroundTransparency = 1
inputRow1.Parent = promptSection

local activationRangeLabel = Instance.new("TextLabel")
activationRangeLabel.Size = UDim2.new(0.45, 0, 1, 0)
activationRangeLabel.BackgroundTransparency = 1
activationRangeLabel.Text = "Range:"
activationRangeLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
activationRangeLabel.Font = Enum.Font.Gotham
activationRangeLabel.TextSize = 11
activationRangeLabel.TextXAlignment = Enum.TextXAlignment.Left
activationRangeLabel.Parent = inputRow1

local activationRangeBox = Instance.new("TextBox")
activationRangeBox.Size = UDim2.new(0.45, 0, 1, 0)
activationRangeBox.Position = UDim2.new(0.5, 0, 0, 0)
activationRangeBox.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
activationRangeBox.Text = tostring(_G.SmartActivationRange)
activationRangeBox.TextColor3 = Color3.fromRGB(255, 255, 255)
activationRangeBox.Font = Enum.Font.Gotham
activationRangeBox.TextSize = 11
activationRangeBox.TextXAlignment = Enum.TextXAlignment.Center
activationRangeBox.ClearTextOnFocus = false
activationRangeBox.Parent = inputRow1

activationRangeBox.FocusLost:Connect(function()
    local num = tonumber(activationRangeBox.Text)
    if num then
        num = math.clamp(num, 0, 1000)
        activationRangeBox.Text = tostring(num)
        _G.SmartActivationRange = num
        settings.SmartActivationRange = num
    else
        activationRangeBox.Text = tostring(_G.SmartActivationRange)
    end
end)

-- Second row for delay input
local inputRow2 = Instance.new("Frame")
inputRow2.Size = UDim2.new(1, -10, 0, 25)
inputRow2.Position = UDim2.new(0, 5, 0, 275)
inputRow2.BackgroundTransparency = 1
inputRow2.Parent = promptSection

local activationDelayLabel = Instance.new("TextLabel")
activationDelayLabel.Size = UDim2.new(0.45, 0, 1, 0)
activationDelayLabel.BackgroundTransparency = 1
activationDelayLabel.Text = "Delay (s):"
activationDelayLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
activationDelayLabel.Font = Enum.Font.Gotham
activationDelayLabel.TextSize = 11
activationDelayLabel.TextXAlignment = Enum.TextXAlignment.Left
activationDelayLabel.Parent = inputRow2

local activationDelayBox = Instance.new("TextBox")
activationDelayBox.Size = UDim2.new(0.45, 0, 1, 0)
activationDelayBox.Position = UDim2.new(0.5, 0, 0, 0)
activationDelayBox.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
activationDelayBox.Text = tostring(_G.SmartActivationDelay)
activationDelayBox.TextColor3 = Color3.fromRGB(255, 255, 255)
activationDelayBox.Font = Enum.Font.Gotham
activationDelayBox.TextSize = 11
activationDelayBox.TextXAlignment = Enum.TextXAlignment.Center
activationDelayBox.ClearTextOnFocus = false
activationDelayBox.Parent = inputRow2

activationDelayBox.FocusLost:Connect(function()
    local num = tonumber(activationDelayBox.Text)
    if num then
        num = math.clamp(num, 0.1, 5)
        activationDelayBox.Text = tostring(num)
        _G.SmartActivationDelay = num
        settings.SmartActivationDelay = num
    else
        activationDelayBox.Text = tostring(_G.SmartActivationDelay)
    end
end)

-- Manual Activate All Button
local manualActivateButton = Instance.new("TextButton")
manualActivateButton.Size = UDim2.new(1, -10, 0, 30)
manualActivateButton.Position = UDim2.new(0, 5, 0, 305)
manualActivateButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
manualActivateButton.BackgroundTransparency = 0.3
manualActivateButton.Text = "FORCE ACTIVATE ALL (E KEY)"
manualActivateButton.TextColor3 = Color3.fromRGB(255, 255, 255)
manualActivateButton.Font = Enum.Font.GothamBold
manualActivateButton.TextSize = 11
manualActivateButton.Parent = promptSection

manualActivateButton.MouseButton1Click:Connect(function()
    manualActivateAllPrompts()
end)

-- Class Selection
local classSection = Instance.new("Frame")
classSection.Size = UDim2.new(1, 0, 0, 100)
classSection.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
classSection.Parent = ScrollFrame

local classTitle = Instance.new("TextLabel")
classTitle.Size = UDim2.new(1, -10, 0, 20)
classTitle.Position = UDim2.new(0, 5, 0, 5)
classTitle.BackgroundTransparency = 1
classTitle.Text = "CLASS SELECTION"
classTitle.TextColor3 = Color3.fromRGB(180, 180, 255)
classTitle.Font = Enum.Font.GothamBold
classTitle.TextSize = 12
classTitle.TextXAlignment = Enum.TextXAlignment.Left
classTitle.Parent = classSection

local classContainer = Instance.new("Frame")
classContainer.Size = UDim2.new(1, -10, 0, 70)
classContainer.Position = UDim2.new(0, 5, 0, 25)
classContainer.BackgroundTransparency = 1
classContainer.Parent = classSection

-- Create a grid for class buttons
local classButtons = {
    {name = "Medic", color = Color3.fromRGB(220, 60, 60), classType = "medic"},
    {name = "Engi", color = Color3.fromRGB(60, 180, 220), classType = "engineer"},
    {name = "Rifle", color = Color3.fromRGB(60, 220, 60), classType = "rifleman"},
    {name = "Officer", color = Color3.fromRGB(220, 180, 60), classType = "officer"},
    {name = "MG", color = Color3.fromRGB(180, 60, 220), classType = "machinegun"}
}

for i, classInfo in ipairs(classButtons) do
    local row = math.floor((i-1)/3)
    local col = (i-1) % 3
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.3, -2, 0, 20)
    button.Position = UDim2.new(col * 0.33, 0, row * 0.5, 0)
    button.BackgroundColor3 = classInfo.color
    button.BackgroundTransparency = 0.3
    button.Text = classInfo.name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 10
    button.Parent = classContainer
    
    button.MouseButton1Click:Connect(function()
        selectClass(classInfo.classType)
    end)
end

-- Create a container for remaining settings
local settingsSection = Instance.new("Frame")
settingsSection.Size = UDim2.new(1, 0, 0, 400)
settingsSection.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
settingsSection.Parent = ScrollFrame

local settingsTitle = Instance.new("TextLabel")
settingsTitle.Size = UDim2.new(1, -10, 0, 20)
settingsTitle.Position = UDim2.new(0, 5, 0, 5)
settingsTitle.BackgroundTransparency = 1
settingsTitle.Text = "COMBAT SETTINGS"
settingsTitle.TextColor3 = Color3.fromRGB(180, 255, 180)
settingsTitle.Font = Enum.Font.GothamBold
settingsTitle.TextSize = 12
settingsTitle.TextXAlignment = Enum.TextXAlignment.Left
settingsTitle.Parent = settingsSection

-- Use a ScrollingFrame inside settings for better organization
local settingsScroll = Instance.new("ScrollingFrame")
settingsScroll.Size = UDim2.new(1, -10, 0, 370)
settingsScroll.Position = UDim2.new(0, 5, 0, 30)
settingsScroll.BackgroundTransparency = 1
settingsScroll.ScrollBarThickness = 4
settingsScroll.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
settingsScroll.CanvasSize = UDim2.new(0, 0, 0, 800)
settingsScroll.Parent = settingsSection

local settingsList = Instance.new("UIListLayout")
settingsList.Padding = UDim.new(0, 8)
settingsList.Parent = settingsScroll

-- Head Size Input
local hitboxSizeInput = createNumberInput("Head Scale (10-500)", 10, 500, _G.NPCHeadSize, function(value)
    _G.NPCHeadSize = value
    if _G.HitboxAllEnabled then
        for npc, _ in pairs(TrackedNPCs) do
            scaleNPCHead(npc, value)
        end
    end
end)
hitboxSizeInput.Parent = settingsScroll

-- Master Toggle
local masterToggle, updateMasterToggle = createToggleButton("Enable Features", not _G.Disabled, function(value)
    _G.Disabled = not value
end)
masterToggle.Parent = settingsScroll
toggleUpdateFunctions["Enable Features"] = updateMasterToggle

-- NPC Detection Toggle
local npcToggle, updateNPCToggle = createToggleButton("NPC Detection", _G.NPCEnabled, function(value)
    _G.NPCEnabled = value
    if not value then
        for npc, _ in pairs(TrackedNPCs) do
            removeESP(npc)
            resetNPCHead(npc)
        end
        TrackedNPCs = {}
        ESPInstances = {}
        HeadScaleInstances = {}
    end
end)
npcToggle.Parent = settingsScroll
toggleUpdateFunctions["NPC Detection"] = updateNPCToggle

-- Hitbox All Enemies Toggle
local hitboxAllToggle, updateHitboxAllToggle = createToggleButton("Hitbox All Enemies", _G.HitboxAllEnabled, function(value)
    _G.HitboxAllEnabled = value
    if value then
        for npc, _ in pairs(TrackedNPCs) do
            scaleNPCHead(npc, _G.NPCHeadSize)
        end
    else
        resetAllHeadScales()
    end
end)
hitboxAllToggle.Parent = settingsScroll
toggleUpdateFunctions["Hitbox All Enemies"] = updateHitboxAllToggle

-- ESP Toggle
local espToggle, updateESPToggle = createToggleButton("Mini Health ESP", _G.ESPEnabled, function(value)
    _G.ESPEnabled = value
    if value then
        for npc, _ in pairs(TrackedNPCs) do
            createESP(npc)
        end
    else
        for npc, esp in pairs(ESPInstances) do
            esp:Destroy()
        end
        ESPInstances = {}
    end
end)
espToggle.Parent = settingsScroll
toggleUpdateFunctions["Mini Health ESP"] = updateESPToggle

-- Auto Throw Grenade Toggle
local autoThrowToggle, updateAutoThrowToggle = createToggleButton("Auto Throw Grenade", _G.AutoThrowGrenade, function(value)
    _G.AutoThrowGrenade = value
    if value then
        startAutoThrow()
    end
end)
autoThrowToggle.Parent = settingsScroll
toggleUpdateFunctions["Auto Throw Grenade"] = updateAutoThrowToggle

-- Auto Throw Delay Input
local autoThrowDelayInput = createNumberInput("Grenade Delay (0.05-1s)", 0.05, 1, _G.AutoThrowDelay, function(value)
    _G.AutoThrowDelay = value
end)
autoThrowDelayInput.Parent = settingsScroll

-- NEW: Manual Ornamlll Throw Button
local ornamlllButton = Instance.new("TextButton")
ornamlllButton.Size = UDim2.new(1, 0, 0, 30)
ornamlllButton.BackgroundColor3 = Color3.fromRGB(180, 80, 220)
ornamlllButton.BackgroundTransparency = 0.3
ornamlllButton.Text = "THROW ORNAMILLL GRENADE"
ornamlllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ornamlllButton.Font = Enum.Font.GothamBold
ornamlllButton.TextSize = 12
ornamlllButton.Parent = settingsScroll

ornamlllButton.MouseButton1Click:Connect(function()
    manualThrowOrnamlll()
end)

-- Aimbot Toggle
local aimbotToggle, updateAimbotToggle = createToggleButton("Aimbot", _G.AimbotEnabled, function(value)
    _G.AimbotEnabled = value
end)
aimbotToggle.Parent = settingsScroll
toggleUpdateFunctions["Aimbot"] = updateAimbotToggle

-- Aimbot FOV Input
local aimbotFOVInput = createNumberInput("Aimbot FOV (20-360)", 20, 360, _G.AimbotFOV, function(value)
    _G.AimbotFOV = value
end)
aimbotFOVInput.Parent = settingsScroll

-- Aimbot Smoothness Input
local aimbotSmoothInput = createNumberInput("Aimbot Smoothness (0.1-1)", 0.1, 1, _G.AimbotSmoothness, function(value)
    _G.AimbotSmoothness = value
end)
aimbotSmoothInput.Parent = settingsScroll

-- Auto Shoot Toggle
local autoShootToggle, updateAutoShootToggle = createToggleButton("Auto Shoot", _G.AimbotAutoShoot, function(value)
    _G.AimbotAutoShoot = value
end)
autoShootToggle.Parent = settingsScroll
toggleUpdateFunctions["Auto Shoot"] = updateAutoShootToggle

-- Auto Cook Toggle
local autoCookToggle, updateAutoCookToggle = createToggleButton("Auto Cook Bread", _G.AutoCookBread, function(value)
    _G.AutoCookBread = value
    if value then
        startAutoCook()
    else
        cooking = false
    end
end)
autoCookToggle.Parent = settingsScroll
toggleUpdateFunctions["Auto Cook Bread"] = updateAutoCookToggle

-- Auto Cook Delay Input
local autoCookDelayInput = createNumberInput("Cook Delay (0.1-5s)", 0.1, 5, _G.AutoCookDelay, function(value)
    _G.AutoCookDelay = value
end)
autoCookDelayInput.Parent = settingsScroll

local manualCookButton = Instance.new("TextButton")
manualCookButton.Size = UDim2.new(1, 0, 0, 30)
manualCookButton.BackgroundColor3 = Color3.fromRGB(180, 140, 80)
manualCookButton.BackgroundTransparency = 0.3
manualCookButton.Text = "COOK BREAD ONCE"
manualCookButton.TextColor3 = Color3.fromRGB(255, 255, 255)
manualCookButton.Font = Enum.Font.GothamBold
manualCookButton.TextSize = 12
manualCookButton.Parent = settingsScroll

manualCookButton.MouseButton1Click:Connect(function()
    cookBread()
end)

-- Reset Button
local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(1, 0, 0, 30)
resetButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
resetButton.Text = "RESET TO DEFAULTS"
resetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
resetButton.Font = Enum.Font.GothamBold
resetButton.TextSize = 12
resetButton.Parent = settingsScroll

resetButton.MouseButton1Click:Connect(function()
    _G.NPCHeadSize = 100
    _G.Disabled = false
    _G.NPCEnabled = true
    _G.ESPEnabled = false
    _G.AimbotEnabled = false
    _G.HitboxAllEnabled = false
    _G.AimbotFOV = 100
    _G.AimbotSmoothness = 0.3
    _G.AimbotWallCheck = false
    _G.AimbotAutoShoot = false
    _G.AimbotMaxDistance = 500
    _G.AutoCookBread = false
    _G.AutoCookDelay = 0.3
    _G.AutoThrowGrenade = false
    _G.AutoThrowDelay = 0.1
    _G.SmartAutoActivate = false
    _G.SmartActivationRange = 100
    _G.SmartActivationDelay = 0.3
    _G.BypassAllRestrictions = true
    _G.SmartCycleMode = true
    _G.ActivateAllNearby = false
    _G.ActivateAllDelay = 0.3
    _G.AutoEngineering = false
    
    -- Reset GUI toggles
    if toggleUpdateFunctions["Enable Features"] then toggleUpdateFunctions["Enable Features"](true) end
    if toggleUpdateFunctions["NPC Detection"] then toggleUpdateFunctions["NPC Detection"](true) end
    if toggleUpdateFunctions["Hitbox All Enemies"] then toggleUpdateFunctions["Hitbox All Enemies"](false) end
    if toggleUpdateFunctions["Mini Health ESP"] then toggleUpdateFunctions["Mini Health ESP"](false) end
    if toggleUpdateFunctions["Auto Throw Grenade"] then toggleUpdateFunctions["Auto Throw Grenade"](false) end
    if toggleUpdateFunctions["Aimbot"] then toggleUpdateFunctions["Aimbot"](false) end
    if toggleUpdateFunctions["Auto Shoot"] then toggleUpdateFunctions["Auto Shoot"](false) end
    if toggleUpdateFunctions["Auto Cook Bread"] then toggleUpdateFunctions["Auto Cook Bread"](false) end
    if toggleUpdateFunctions["Bypass All Restrictions"] then toggleUpdateFunctions["Bypass All Restrictions"](true) end
    if toggleUpdateFunctions["Smart Cycle Mode"] then toggleUpdateFunctions["Smart Cycle Mode"](true) end
    if toggleUpdateFunctions["Activate ALL Nearby"] then toggleUpdateFunctions["Activate ALL Nearby"](false) end
    if toggleUpdateFunctions["Auto Engineering"] then toggleUpdateFunctions["Auto Engineering"](false) end
    
    -- Reset text boxes
    activationRangeBox.Text = "100"
    activationDelayBox.Text = "0.3"
    
    toggleSmartActivation(false)
    toggleActivateAllNearby(false)
    toggleAutoEngineering(false)
    
    resetAllHeadScales()
    for npc, esp in pairs(ESPInstances) do
        esp:Destroy()
    end
    ESPInstances = {}
    TrackedNPCs = {}
    cooking = false
    throwingGrenade = false
end)

-- Update scroll frame size
settingsList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    settingsScroll.CanvasSize = UDim2.new(0, 0, 0, settingsList.AbsoluteContentSize.Y + 20)
end)

UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + 20)
end)

local function toggleGUI()
    MainFrame.Visible = not MainFrame.Visible
end

TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local dragStart = input.Position
        local frameStart = MainFrame.Position
        
        local connection
        connection = UserInputService.InputChanged:Connect(function(moveInput)
            if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = moveInput.Position - dragStart
                MainFrame.Position = UDim2.new(
                    frameStart.X.Scale, frameStart.X.Offset + delta.X,
                    frameStart.Y.Scale, frameStart.Y.Offset + delta.Y
                )
            end
        end)
        
        UserInputService.InputEnded:Connect(function(endInput)
            if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                connection:Disconnect()
            end
        end)
    end
end)

CloseButton.MouseButton1Click:Connect(toggleGUI)

local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 40, 0, 40)
ToggleButton.Position = UDim2.new(1, -50, 0, 10)
ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
ToggleButton.BackgroundTransparency = 0.1
ToggleButton.Text = "⚙"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.TextSize = 20
ToggleButton.Parent = ScreenGui

ToggleButton.MouseButton1Click:Connect(toggleGUI)

UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.Insert then
        toggleGUI()
    end
end)

isRunning = true
spawn(function()
    while isRunning do
        mainLoop()
        wait(0.03)
    end
end)

game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        isRunning = false
        toggleSmartActivation(false)
        toggleActivateAllNearby(false)
        toggleAutoEngineering(false)
        resetAllHeadScales()
        ScreenGui:Destroy()
    end
end)

print("==========================================")
print("ULTRA-SMART PROMPT ACTIVATOR LOADED")
print("==========================================")
print("Press INSERT to open/close GUI")
print("")
print("KEY UPDATES:")
print("1. ORNAMILL GRENADE SYSTEM:")
print("   • Auto-throw prioritizes 'ornamlll' over 'mill'")
print("   • Rifleman class keeps both grenade types in inventory")
print("   • Added 'THROW ORNAMILLL GRENADE' button to GUI")
print("   • Requests 'ornamlll' via GetOrnamlll remote when available")
print("")
print("2. CLIENT-SIDE VISUAL HITBOXES:")
print("   • Visual overlay spheres attached to NPC heads")
print("   • Works client-side without server access")
print("   • Adjustable size via Head Scale slider")
print("   • Purely visual reference for aiming")
print("")
print("3. AUTO ENGINEERING FEATURE (REWORKED):")
print("   • Uses engineer remote EVERY SECOND")
print("   • Auto equips wire spools EVERY SECOND")
print("   • Clicks wire spools EVERY SECOND")
print("   • Removes wire spools after 6 uses")
print("   • Continuous loop for maximum wire spool usage")
print("")
print("ULTRA-SMART FEATURES:")
print("1. ULTRA-SMART CYCLE: No repeat until all others activated")
print("2. ACTIVATE ALL NEARBY: Fires EVERY prompt in range every 0.3s")
print("3. Bypasses ALL restrictions and cooldowns")
print("4. Fixed GUI layout with all settings visible")
print("5. Force activates EVERY prompt in range")
print("6. AUTO ENGINEERING: Auto wire spool usage system (1s loop)")
print("")
print("COMBAT FEATURES:")
print("• Auto Throw Grenade (prioritizes ornamlll)")
print("• Manual Throw Ornamlll button")
print("• Class Selection (Medic, Engineer, Rifleman, Officer, MG)")
print("• Auto Cook Bread")
print("• Aimbot with adjustable FOV and smoothness")
print("• ESP with health bars")
print("• Visual Hitbox Overlay System")
print("==========================================")
print("Smart Cycle Logic:")
print("- Each prompt activated exactly once per cycle")
print("- Won't repeat same prompt until all others activated")
print("- Perfect for artillery and multi-step systems")
print("==========================================")
print("Visual Hitbox System:")
print("- Creates transparent spheres around NPC heads")
print("- Client-side only for visual reference")
print("- Helps with aiming but doesn't affect server hit detection")
print("- Can be toggled on/off in settings")
print("==========================================")
print("Auto Engineering System (REWORKED):")
print("- Calls engineer remote EVERY SECOND")
print("- Auto equips ALL wire spools EVERY SECOND")
print("- Clicks ALL wire spools EVERY SECOND")
print("- Removes wire spools after 6 uses")
print("- Maximum wire spool production and usage")
print("- Continuous 1-second loop for efficiency")
print("==========================================")
