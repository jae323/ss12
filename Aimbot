-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Settings
_G.NPCHeadSize = 100
_G.Disabled = false
_G.NPCEnabled = true
_G.ESPEnabled = false
_G.AimbotEnabled = false
_G.HitboxAllEnabled = false
_G.AimbotFOV = 100
_G.AimbotSmoothness = 0.3
_G.AimbotWallCheck = false
_G.AimbotAutoShoot = false
_G.AimbotMaxDistance = 500
_G.AutoCookBread = false
_G.AutoCookDelay = 0.3
-- NEW: Auto Throw Grenade Settings
_G.AutoThrowGrenade = false
_G.AutoThrowDelay = 0.1  -- Changed to 0.1 for faster throwing

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local TrackedNPCs = {}
local ESPInstances = {}
local HeadScaleInstances = {}
local currentTarget = nil
local isRunning = false
local cooking = false
local throwingGrenade = false
local lastThrowTime = 0

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "WhizzbangGUI"
ScreenGui.Parent = CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- NPC Detection
local function isNPC(model)
    if not model or not model:IsA("Model") then return false end
    if model.Name:lower():find("prop") then return false end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character == model then
            return false
        end
    end
    
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    return true
end

-- Simple head scaling
local function scaleNPCHead(npc, scaleMultiplier)
    if not npc or not npc.Parent then return end
    
    local head = npc:FindFirstChild("Head")
    if not head then return end
    
    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    -- Store original if not already stored
    if not HeadScaleInstances[npc] then
        local mesh = head:FindFirstChildOfClass("SpecialMesh")
        HeadScaleInstances[npc] = {
            OriginalSize = head.Size,
            OriginalMeshScale = mesh and mesh.Scale or Vector3.new(1, 1, 1),
            Mesh = mesh
        }
    end
    
    -- Apply scaling
    local data = HeadScaleInstances[npc]
    local scaleValue = scaleMultiplier / 20
    if scaleValue < 1.5 then scaleValue = 1.5 end
    
    if data.Mesh and data.Mesh.Parent == head then
        data.Mesh.Scale = data.OriginalMeshScale * scaleValue
    else
        head.Size = data.OriginalSize * scaleValue
    end
end

local function resetNPCHead(npc)
    if HeadScaleInstances[npc] then
        local head = npc:FindFirstChild("Head")
        if head then
            local data = HeadScaleInstances[npc]
            if data.Mesh and data.Mesh.Parent == head then
                data.Mesh.Scale = data.OriginalMeshScale
            else
                head.Size = data.OriginalSize
            end
        end
        HeadScaleInstances[npc] = nil
    end
end

local function resetAllHeadScales()
    for npc, _ in pairs(HeadScaleInstances) do
        resetNPCHead(npc)
    end
    HeadScaleInstances = {}
end

-- Simple Compact ESP
local function createESP(npc)
    if ESPInstances[npc] then return end
    
    local espContainer = Instance.new("Frame")
    espContainer.Name = "ESP_" .. npc.Name
    espContainer.BackgroundTransparency = 1
    espContainer.Size = UDim2.new(0, 40, 0, 12)
    espContainer.Visible = false
    espContainer.ZIndex = 999
    ESPInstances[npc] = espContainer
    
    -- Small health bar
    local healthBar = Instance.new("Frame")
    healthBar.Name = "HealthBar"
    healthBar.Size = UDim2.new(1, 0, 0.5, 0)
    healthBar.Position = UDim2.new(0, 0, 0.5, 0)
    healthBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    healthBar.BackgroundTransparency = 0.3
    healthBar.BorderSizePixel = 0
    healthBar.ZIndex = 1000
    healthBar.Parent = espContainer
    
    local healthFill = Instance.new("Frame")
    healthFill.Name = "HealthFill"
    healthFill.Size = UDim2.new(1, 0, 1, 0)
    healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    healthFill.BackgroundTransparency = 0.2
    healthFill.BorderSizePixel = 0
    healthFill.ZIndex = 1001
    healthFill.Parent = healthBar
    
    -- Health text
    local healthText = Instance.new("TextLabel")
    healthText.Name = "HealthText"
    healthText.Size = UDim2.new(1, 0, 0.5, 0)
    healthText.Position = UDim2.new(0, 0, 0, 0)
    healthText.BackgroundTransparency = 1
    healthText.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthText.TextSize = 8
    healthText.Font = Enum.Font.Gotham
    healthText.TextStrokeTransparency = 0.7
    healthText.ZIndex = 1000
    healthText.Parent = espContainer
    
    espContainer.Parent = ScreenGui
end

local function removeESP(npc)
    if ESPInstances[npc] then
        ESPInstances[npc]:Destroy()
        ESPInstances[npc] = nil
    end
end

local function updateESP()
    if not _G.ESPEnabled then return end
    
    for npc, esp in pairs(ESPInstances) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local screenPoint, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 2, 0))
                
                if onScreen then
                    esp.Position = UDim2.new(0, screenPoint.X - 20, 0, screenPoint.Y - 6)
                    esp.Visible = true
                    
                    -- Update health
                    local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                    local healthFill = esp:FindFirstChild("HealthBar"):FindFirstChild("HealthFill")
                    local healthText = esp:FindFirstChild("HealthText")
                    
                    if healthFill then
                        healthFill.Size = UDim2.new(healthPercent, 0, 1, 0)
                        
                        -- Color based on health
                        if healthPercent > 0.6 then
                            healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                        elseif healthPercent > 0.3 then
                            healthFill.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
                        else
                            healthFill.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                        end
                    end
                    
                    if healthText then
                        healthText.Text = math.floor(humanoid.Health)
                    end
                else
                    esp.Visible = false
                end
            else
                removeESP(npc)
            end
        else
            removeESP(npc)
        end
    end
end

-- Get closest NPC for grenade throwing (360 degree, no distance limit)
local function getClosestNPCForGrenade()
    local closest = nil
    local closestDistance = math.huge
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    local myPosition = humanoidRootPart.Position
    
    for npc, _ in pairs(TrackedNPCs) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local distance = (head.Position - myPosition).Magnitude
                
                if distance < closestDistance then
                    closestDistance = distance
                    closest = npc
                end
            end
        end
    end
    
    return closest
end

-- Clean inventory for auto-throw (keep only "mill" items)
local function cleanInventoryForThrow()
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Clean backpack
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                -- Keep only "mill" items (case-insensitive)
                local itemName = item.Name:lower()
                if itemName ~= "mill" then
                    item:Destroy()
                end
            end
        end
    end
    
    -- Clean character tools
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            -- Keep only "mill" items (case-insensitive)
            local itemName = item.Name:lower()
            if itemName ~= "mill" then
                item:Destroy()
            end
        end
    end
end

-- Simple Aimbot (for shooting)
local function getClosestNPC()
    local closest = nil
    local closestDistance = math.huge
    local cameraPos = Camera.CFrame.Position
    
    for npc, _ in pairs(TrackedNPCs) do
        if npc and npc.Parent then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and humanoid.Health > 0 and head then
                local distance = (head.Position - cameraPos).Magnitude
                if distance > _G.AimbotMaxDistance then continue end
                
                local screenPoint, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    local pointVector = Vector2.new(screenPoint.X, screenPoint.Y)
                    local distanceFromCenter = (pointVector - screenCenter).Magnitude
                    local fovRadius = (_G.AimbotFOV / 100) * math.min(Camera.ViewportSize.X, Camera.ViewportSize.Y) / 2
                    
                    if distanceFromCenter <= fovRadius and distance < closestDistance then
                        closestDistance = distance
                        closest = npc
                    end
                end
            end
        end
    end
    
    return closest
end

local function smoothAim(targetPosition)
    local currentCF = Camera.CFrame
    local currentPos = currentCF.Position
    
    local lookVector = (targetPosition - currentPos).Unit
    local currentLook = currentCF.LookVector
    
    local newLook = currentLook:Lerp(lookVector, _G.AimbotSmoothness)
    Camera.CFrame = CFrame.new(currentPos, currentPos + newLook)
end

-- Auto Throw Grenade Function (UPDATED)
local function autoThrowGrenade()
    if not _G.AutoThrowGrenade then return end
    if throwingGrenade then return end
    
    local currentTime = tick()
    if currentTime - lastThrowTime < _G.AutoThrowDelay then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    -- Get closest enemy for grenade throwing
    local targetNPC = getClosestNPCForGrenade()
    if not targetNPC then return end
    
    local targetHead = targetNPC:FindFirstChild("Head")
    if not targetHead then return end
    
    throwingGrenade = true
    
    -- Step 1: Clean inventory (keep only "mill" items)
    cleanInventoryForThrow()
    
    -- Step 2: Try to get grenades from riflemen remote
    pcall(function()
        local remotePath = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("Player"):WaitForChild("ChooseClass")
        -- Fire riflemen class remote to get grenades
        remotePath:FireServer("rifle", "rifleman")
    end)
    
    wait(0.05) -- Reduced wait for faster throwing
    
    -- Step 3: Look for "mill" item (grenade) in inventory
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local grenadeTool = nil
    
    -- Check backpack first
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "mill" then
                grenadeTool = item
                break
            end
        end
    end
    
    -- Check character
    if not grenadeTool then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == "mill" then
                grenadeTool = item
                break
            end
        end
    end
    
    if grenadeTool then
        -- Equip the grenade (faster)
        humanoid:EquipTool(grenadeTool)
        
        -- Face the target with improved aiming
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Aim slightly above the head for better throwing arc
            local targetPosition = targetHead.Position + Vector3.new(0, 5, 0) -- 5 studs above head
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
        end
        
        -- Very short wait before throwing
        wait(0.05)
        
        -- Simulate clicking the grenade tool (use it)
        grenadeTool:Activate()
        
        -- Short wait after throwing
        wait(0.05)
        
        print("Threw grenade at enemy: " .. targetNPC.Name)
        lastThrowTime = currentTime
    else
        -- If no grenade found, try to get one directly
        pcall(function()
            -- Try alternative grenade remote if exists
            local grenadeRemote = ReplicatedStorage:FindFirstChild("RemoteEvents"):FindFirstChild("GetGrenade")
            if grenadeRemote then
                grenadeRemote:FireServer()
            end
        end)
        print("No 'mill' grenade found, requesting more...")
    end
    
    throwingGrenade = false
end

-- Start auto throw grenade loop
local function startAutoThrow()
    spawn(function()
        while _G.AutoThrowGrenade do
            autoThrowGrenade()
            wait(0.05) -- Faster checking for continuous throwing
        end
    end)
end

-- Main Game Loop
local function mainLoop()
    if _G.Disabled or not _G.NPCEnabled then
        -- Clean up
        for npc, _ in pairs(TrackedNPCs) do
            removeESP(npc)
            resetNPCHead(npc)
        end
        TrackedNPCs = {}
        ESPInstances = {}
        HeadScaleInstances = {}
        currentTarget = nil
        return
    end
    
    -- 1. Find and track NPCs
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA("Model") and not TrackedNPCs[model] then
            if isNPC(model) then
                TrackedNPCs[model] = true
                
                -- Create ESP if enabled
                if _G.ESPEnabled then
                    createESP(model)
                end
                
                -- Scale head if enabled
                if _G.HitboxAllEnabled then
                    scaleNPCHead(model, _G.NPCHeadSize)
                end
            end
        end
    end
    
    -- 2. Clean up dead/removed NPCs
    for npc, _ in pairs(TrackedNPCs) do
        if not npc.Parent or not isNPC(npc) then
            TrackedNPCs[npc] = nil
            removeESP(npc)
            resetNPCHead(npc)
        end
    end
    
    -- 3. Update ESP
    updateESP()
    
    -- 4. Run Aimbot
    if _G.AimbotEnabled and LocalPlayer.Character then
        local targetNPC = getClosestNPC()
        
        if targetNPC then
            local head = targetNPC:FindFirstChild("Head")
            if head then
                smoothAim(head.Position)
                
                -- Auto shoot
                if _G.AimbotAutoShoot then
                    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    if tool then
                        for _, v in ipairs(tool:GetDescendants()) do
                            if v:IsA("RemoteEvent") then
                                pcall(function() v:FireServer() end)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Bread Cooking
local function cookBread()
    pcall(function()
        local breadFolder = ReplicatedStorage:FindFirstChild("Bread")
        if breadFolder then
            local kneadRemote = breadFolder:FindFirstChild("KneadBread")
            local cookRemote = breadFolder:FindFirstChild("CookRaw")
            
            if kneadRemote then
                kneadRemote:FireServer("stale bred")
            end
            
            if cookRemote then
                cookRemote:FireServer(10)
            end
        end
    end)
end

local function startAutoCook()
    if cooking then return end
    cooking = true
    
    spawn(function()
        while _G.AutoCookBread do
            cookBread()
            wait(_G.AutoCookDelay)
        end
        cooking = false
    end)
end

-- Class Selection with Inventory Management
local function cleanupInventory(keepItemName)
    local character = LocalPlayer.Character
    if not character then return end
    
    -- 1. Clear backpack
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                -- Keep only the specified item (case-insensitive)
                local itemName = item.Name:lower()
                local keepName = keepItemName:lower()
                if itemName ~= keepName then
                    item:Destroy()
                    print("Deleted item from backpack: " .. item.Name)
                else
                    print("Kept item in backpack: " .. item.Name)
                end
            end
        end
    end
    
    -- 2. Clear character tools
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            -- Keep only the specified item (case-insensitive)
            local itemName = item.Name:lower()
            local keepName = keepItemName:lower()
            if itemName ~= keepName then
                item:Destroy()
                print("Deleted item from character: " .. item.Name)
            else
                print("Kept item in character: " .. item.Name)
            end
        end
    end
    
    -- 3. Check if we have the keep item, if not, try to find and give it
    local hasKeepItem = false
    
    -- Check backpack
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == keepItemName:lower() then
                hasKeepItem = true
                break
            end
        end
    end
    
    -- Check character
    if not hasKeepItem then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") and item.Name:lower() == keepItemName:lower() then
                hasKeepItem = true
                break
            end
        end
    end
    
    -- If no keep item found, try to find it
    if not hasKeepItem then
        print("No '" .. keepItemName .. "' item found, searching...")
        
        local itemTemplate = nil
        
        -- Search in common locations
        local function searchInFolder(folder)
            if not folder then return nil end
            for _, item in ipairs(folder:GetChildren()) do
                if item:IsA("Tool") and item.Name:lower() == keepItemName:lower() then
                    return item
                end
            end
            return nil
        end
        
        -- Check ReplicatedStorage
        itemTemplate = searchInFolder(ReplicatedStorage:FindFirstChild("Tools"))
        if not itemTemplate then
            itemTemplate = searchInFolder(ReplicatedStorage:FindFirstChild("Weapons"))
        end
        if not itemTemplate then
            itemTemplate = searchInFolder(ReplicatedStorage:FindFirstChild("Items"))
        end
        
        -- Check ServerStorage
        if not itemTemplate then
            local ServerStorage = game:GetService("ServerStorage")
            itemTemplate = searchInFolder(ServerStorage:FindFirstChild("Tools"))
            if not itemTemplate then
                itemTemplate = searchInFolder(ServerStorage:FindFirstChild("Weapons"))
            end
            if not itemTemplate then
                itemTemplate = searchInFolder(ServerStorage:FindFirstChild("Items"))
            end
        end
        
        -- If found, clone it
        if itemTemplate then
            local clonedItem = itemTemplate:Clone()
            clonedItem.Parent = backpack or character
            print("Found and gave '" .. keepItemName .. "' item from template")
        else
            -- Create a basic tool
            local newTool = Instance.new("Tool")
            newTool.Name = keepItemName
            newTool.ToolTip = keepItemName .. " Tool"
            
            -- Add a handle
            local handle = Instance.new("Part")
            handle.Name = "Handle"
            handle.Size = Vector3.new(0.5, 0.5, 2)
            handle.Parent = newTool
            
            newTool.Parent = backpack or character
            print("Created default '" .. keepItemName .. "' tool")
        end
    else
        print("Inventory cleaned. Keeping only '" .. keepItemName .. "' item.")
    end
end

local function selectClass(classType)
    pcall(function()
        local remotePath = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("Player"):WaitForChild("ChooseClass")
        local args = {}
        
        if classType == "medic" then
            args = {"medic", "medic"}
        elseif classType == "engineer" then
            args = {"engi", "engineer"}
        elseif classType == "rifleman" then
            args = {"rifle", "rifleman"}
        elseif classType == "officer" then
            args = {"officer", "officer"}
        elseif classType == "machinegun" then
            args = {"auto", "automatic"}
        end
        
        -- Fire the original remote to select class
        remotePath:FireServer(unpack(args))
        
        -- Wait a moment for the game to give items
        wait(0.5)
        
        -- Clean inventory based on class
        if classType == "rifleman" then
            cleanupInventory("mill")
        elseif classType == "engineer" then
            cleanupInventory("wire spool")
        end
        
        -- Set up cleanup for respawns (60 seconds)
        local cleanupTimer = 60
        local respawnConnection
        
        local function setupRespawnCleanup()
            if respawnConnection then
                respawnConnection:Disconnect()
            end
            
            respawnConnection = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
                wait(1) -- Wait for game to give default items
                if classType == "rifleman" then
                    cleanupInventory("mill")
                elseif classType == "engineer" then
                    cleanupInventory("wire spool")
                end
            end)
        end
        
        setupRespawnCleanup()
        
        -- Disconnect after 60 seconds
        delay(cleanupTimer, function()
            if respawnConnection then
                respawnConnection:Disconnect()
                print("Stopped auto-cleaning inventory for " .. classType)
            end
        end)
        
        print(classType:upper() .. " class selected. All items except the class-specific item will be removed.")
    end)
end

-- GUI SETUP
local function createToggleButton(label, default, callback)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, 30)
    container.BackgroundTransparency = 1
    
    local labelText = Instance.new("TextLabel")
    labelText.Size = UDim2.new(0.7, 0, 1, 0)
    labelText.BackgroundTransparency = 1
    labelText.Text = label
    labelText.TextColor3 = Color3.fromRGB(220, 220, 220)
    labelText.Font = Enum.Font.GothamMedium
    labelText.TextSize = 12
    labelText.TextXAlignment = Enum.TextXAlignment.Left
    labelText.Parent = container
    
    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0.25, 0, 0.7, 0)
    toggleButton.Position = UDim2.new(0.75, 0, 0.15, 0)
    toggleButton.BackgroundColor3 = default and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
    toggleButton.Text = default and "ON" or "OFF"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 11
    toggleButton.Parent = container
    
    local state = default
    
    toggleButton.MouseButton1Click:Connect(function()
        state = not state
        toggleButton.BackgroundColor3 = state and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
        toggleButton.Text = state and "ON" or "OFF"
        callback(state)
    end)
    
    return container, function(newState)
        state = newState
        toggleButton.BackgroundColor3 = state and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(200, 50, 50)
        toggleButton.Text = state and "ON" or "OFF"
        callback(state)
    end
end

local function createNumberInput(label, min, max, default, callback)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, 50)
    container.BackgroundTransparency = 1
    
    local labelText = Instance.new("TextLabel")
    labelText.Size = UDim2.new(1, 0, 0, 20)
    labelText.BackgroundTransparency = 1
    labelText.Text = label
    labelText.TextColor3 = Color3.fromRGB(200, 200, 200)
    labelText.Font = Enum.Font.GothamMedium
    labelText.TextSize = 12
    labelText.TextXAlignment = Enum.TextXAlignment.Left
    labelText.Parent = container
    
    local textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(1, 0, 0, 25)
    textBox.Position = UDim2.new(0, 0, 0, 20)
    textBox.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    textBox.Text = tostring(default)
    textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    textBox.Font = Enum.Font.Gotham
    textBox.TextSize = 12
    textBox.TextXAlignment = Enum.TextXAlignment.Center
    textBox.ClearTextOnFocus = false
    textBox.Parent = container
    
    textBox.FocusLost:Connect(function()
        local num = tonumber(textBox.Text)
        if num then
            num = math.clamp(num, min, max)
            textBox.Text = tostring(num)
            callback(num)
        else
            textBox.Text = tostring(default)
        end
    end)
    
    return container
end

-- Main GUI Frame (Increased height to fit new button)
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 320, 0, 530) -- Increased from 500 to 530
MainFrame.Position = UDim2.new(1, -340, 0.5, -265) -- Adjusted position for new height
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
MainFrame.BackgroundTransparency = 0.05
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false
MainFrame.Parent = ScreenGui

-- Title Bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 30)
TitleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -40, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "WHIZZBANG"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 14
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TitleBar

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 25, 0, 25)
CloseButton.Position = UDim2.new(1, -30, 0.5, -12.5)
CloseButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
CloseButton.Text = "✕"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 14
CloseButton.Parent = TitleBar

-- Content Frame
local ContentFrame = Instance.new("Frame")
ContentFrame.Size = UDim2.new(1, -20, 1, -40)
ContentFrame.Position = UDim2.new(0, 10, 0, 35)
ContentFrame.BackgroundTransparency = 1
ContentFrame.Parent = MainFrame

local ScrollFrame = Instance.new("ScrollingFrame")
ScrollFrame.Size = UDim2.new(1, 0, 1, 0)
ScrollFrame.BackgroundTransparency = 1
ScrollFrame.ScrollBarThickness = 6
ScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ScrollFrame.Parent = ContentFrame

local UIListLayout = Instance.new("UIListLayout")
UIListLayout.Padding = UDim.new(0, 8)
UIListLayout.Parent = ScrollFrame

-- Store update functions
local toggleUpdateFunctions = {}

-- Class Selection
local classSection = Instance.new("Frame")
classSection.Size = UDim2.new(1, 0, 0, 130)
classSection.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
classSection.Parent = ScrollFrame

local classContainer = Instance.new("Frame")
classContainer.Size = UDim2.new(1, -10, 0, 120)
classContainer.Position = UDim2.new(0, 5, 0, 5)
classContainer.BackgroundTransparency = 1
classContainer.Parent = classSection

local classButtons = {
    {name = "Medic", color = Color3.fromRGB(220, 60, 60), classType = "medic"},
    {name = "Engineer", color = Color3.fromRGB(60, 180, 220), classType = "engineer"},
    {name = "Rifleman", color = Color3.fromRGB(60, 220, 60), classType = "rifleman"},
    {name = "Officer", color = Color3.fromRGB(220, 180, 60), classType = "officer"},
    {name = "Machine Gun", color = Color3.fromRGB(180, 60, 220), classType = "machinegun"}
}

for i, classInfo in ipairs(classButtons) do
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, 22)
    button.Position = UDim2.new(0, 0, 0, (i-1)*24)
    button.BackgroundColor3 = classInfo.color
    button.BackgroundTransparency = 0.3
    button.Text = classInfo.name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 11
    button.Parent = classContainer
    
    button.MouseButton1Click:Connect(function()
        selectClass(classInfo.classType)
    end)
end

-- Head Size Input
local hitboxSizeInput = createNumberInput("Head Scale (10-500)", 10, 500, _G.NPCHeadSize, function(value)
    _G.NPCHeadSize = value
    if _G.HitboxAllEnabled then
        for npc, _ in pairs(TrackedNPCs) do
            scaleNPCHead(npc, value)
        end
    end
end)
hitboxSizeInput.Parent = ScrollFrame

-- Master Toggle
local masterToggle, updateMasterToggle = createToggleButton("Enable Features", not _G.Disabled, function(value)
    _G.Disabled = not value
end)
masterToggle.Parent = ScrollFrame
toggleUpdateFunctions["Enable Features"] = updateMasterToggle

-- NPC Detection Toggle
local npcToggle, updateNPCToggle = createToggleButton("NPC Detection", _G.NPCEnabled, function(value)
    _G.NPCEnabled = value
    if not value then
        for npc, _ in pairs(TrackedNPCs) do
            removeESP(npc)
            resetNPCHead(npc)
        end
        TrackedNPCs = {}
        ESPInstances = {}
        HeadScaleInstances = {}
    end
end)
npcToggle.Parent = ScrollFrame
toggleUpdateFunctions["NPC Detection"] = updateNPCToggle

-- Hitbox All Enemies Toggle
local hitboxAllToggle, updateHitboxAllToggle = createToggleButton("Hitbox All Enemies", _G.HitboxAllEnabled, function(value)
    _G.HitboxAllEnabled = value
    if value then
        for npc, _ in pairs(TrackedNPCs) do
            scaleNPCHead(npc, _G.NPCHeadSize)
        end
    else
        resetAllHeadScales()
    end
end)
hitboxAllToggle.Parent = ScrollFrame
toggleUpdateFunctions["Hitbox All Enemies"] = updateHitboxAllToggle

-- ESP Toggle
local espToggle, updateESPToggle = createToggleButton("Mini Health ESP", _G.ESPEnabled, function(value)
    _G.ESPEnabled = value
    if value then
        for npc, _ in pairs(TrackedNPCs) do
            createESP(npc)
        end
    else
        for npc, esp in pairs(ESPInstances) do
            esp:Destroy()
        end
        ESPInstances = {}
    end
end)
espToggle.Parent = ScrollFrame
toggleUpdateFunctions["Mini Health ESP"] = updateESPToggle

-- Auto Throw Grenade Toggle (NEW)
local autoThrowToggle, updateAutoThrowToggle = createToggleButton("Auto Throw Grenade", _G.AutoThrowGrenade, function(value)
    _G.AutoThrowGrenade = value
    if value then
        startAutoThrow()
    end
end)
autoThrowToggle.Parent = ScrollFrame
toggleUpdateFunctions["Auto Throw Grenade"] = updateAutoThrowToggle

-- Auto Throw Delay Input (NEW)
local autoThrowDelayInput = createNumberInput("Grenade Throw Delay (0.05-1s)", 0.05, 1, _G.AutoThrowDelay, function(value)
    _G.AutoThrowDelay = value
end)
autoThrowDelayInput.Parent = ScrollFrame

-- Aimbot FOV Input
local aimbotFOVInput = createNumberInput("Aimbot FOV (20-360)", 20, 360, _G.AimbotFOV, function(value)
    _G.AimbotFOV = value
end)
aimbotFOVInput.Parent = ScrollFrame

-- Aimbot Smoothness Input
local aimbotSmoothInput = createNumberInput("Aimbot Smoothness (0.1-1)", 0.1, 1, _G.AimbotSmoothness, function(value)
    _G.AimbotSmoothness = value
end)
aimbotSmoothInput.Parent = ScrollFrame

-- Aimbot Distance Input
local aimbotDistanceInput = createNumberInput("Max Distance (50-2000)", 50, 2000, _G.AimbotMaxDistance, function(value)
    _G.AimbotMaxDistance = value
end)
aimbotDistanceInput.Parent = ScrollFrame

-- Aimbot Toggle
local aimbotToggle, updateAimbotToggle = createToggleButton("Aimbot", _G.AimbotEnabled, function(value)
    _G.AimbotEnabled = value
end)
aimbotToggle.Parent = ScrollFrame
toggleUpdateFunctions["Aimbot"] = updateAimbotToggle

-- Wall Check Toggle
local wallCheckToggle, updateWallCheckToggle = createToggleButton("Wall Check", _G.AimbotWallCheck, function(value)
    _G.AimbotWallCheck = value
end)
wallCheckToggle.Parent = ScrollFrame
toggleUpdateFunctions["Wall Check"] = updateWallCheckToggle

-- Auto Shoot Toggle
local autoShootToggle, updateAutoShootToggle = createToggleButton("Auto Shoot", _G.AimbotAutoShoot, function(value)
    _G.AimbotAutoShoot = value
end)
autoShootToggle.Parent = ScrollFrame
toggleUpdateFunctions["Auto Shoot"] = updateAutoShootToggle

-- Auto Cook Delay Input
local autoCookDelayInput = createNumberInput("Auto Cook Delay (0.1-5s)", 0.1, 5, _G.AutoCookDelay, function(value)
    _G.AutoCookDelay = value
end)
autoCookDelayInput.Parent = ScrollFrame

-- Auto Cook Toggle
local autoCookToggle, updateAutoCookToggle = createToggleButton("Auto Cook Bread", _G.AutoCookBread, function(value)
    _G.AutoCookBread = value
    if value then
        startAutoCook()
    else
        cooking = false
    end
end)
autoCookToggle.Parent = ScrollFrame
toggleUpdateFunctions["Auto Cook Bread"] = updateAutoCookToggle

local manualCookButton = Instance.new("TextButton")
manualCookButton.Size = UDim2.new(1, 0, 0, 30)
manualCookButton.BackgroundColor3 = Color3.fromRGB(180, 140, 80)
manualCookButton.BackgroundTransparency = 0.3
manualCookButton.Text = "COOK BREAD ONCE"
manualCookButton.TextColor3 = Color3.fromRGB(255, 255, 255)
manualCookButton.Font = Enum.Font.GothamBold
manualCookButton.TextSize = 12
manualCookButton.Parent = ScrollFrame

manualCookButton.MouseButton1Click:Connect(function()
    cookBread()
end)

-- Reset Button
local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(1, 0, 0, 30)
resetButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
resetButton.Text = "RESET TO DEFAULTS"
resetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
resetButton.Font = Enum.Font.GothamBold
resetButton.TextSize = 12
resetButton.Parent = ScrollFrame

resetButton.MouseButton1Click:Connect(function()
    _G.NPCHeadSize = 100
    _G.Disabled = false
    _G.NPCEnabled = true
    _G.ESPEnabled = false
    _G.AimbotEnabled = false
    _G.HitboxAllEnabled = false
    _G.AimbotFOV = 100
    _G.AimbotSmoothness = 0.3
    _G.AimbotWallCheck = false
    _G.AimbotAutoShoot = false
    _G.AimbotMaxDistance = 500
    _G.AutoCookBread = false
    _G.AutoCookDelay = 0.3
    _G.AutoThrowGrenade = false  -- NEW: Reset auto throw
    _G.AutoThrowDelay = 0.1      -- NEW: Reset throw delay (changed to 0.1)
    
    -- Reset GUI toggles
    if toggleUpdateFunctions["Enable Features"] then toggleUpdateFunctions["Enable Features"](true) end
    if toggleUpdateFunctions["NPC Detection"] then toggleUpdateFunctions["NPC Detection"](true) end
    if toggleUpdateFunctions["Hitbox All Enemies"] then toggleUpdateFunctions["Hitbox All Enemies"](false) end
    if toggleUpdateFunctions["Mini Health ESP"] then toggleUpdateFunctions["Mini Health ESP"](false) end
    if toggleUpdateFunctions["Auto Throw Grenade"] then toggleUpdateFunctions["Auto Throw Grenade"](false) end  -- NEW
    if toggleUpdateFunctions["Aimbot"] then toggleUpdateFunctions["Aimbot"](false) end
    if toggleUpdateFunctions["Wall Check"] then toggleUpdateFunctions["Wall Check"](false) end
    if toggleUpdateFunctions["Auto Shoot"] then toggleUpdateFunctions["Auto Shoot"](false) end
    if toggleUpdateFunctions["Auto Cook Bread"] then toggleUpdateFunctions["Auto Cook Bread"](false) end
    
    -- Clear everything
    resetAllHeadScales()
    for npc, esp in pairs(ESPInstances) do
        esp:Destroy()
    end
    ESPInstances = {}
    TrackedNPCs = {}
    cooking = false
    throwingGrenade = false
end)

-- Update scroll frame size
UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + 20)
end)

-- GUI Functions
local function toggleGUI()
    MainFrame.Visible = not MainFrame.Visible
end

-- Make GUI draggable
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local dragStart = input.Position
        local frameStart = MainFrame.Position
        
        local connection
        connection = UserInputService.InputChanged:Connect(function(moveInput)
            if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = moveInput.Position - dragStart
                MainFrame.Position = UDim2.new(
                    frameStart.X.Scale, frameStart.X.Offset + delta.X,
                    frameStart.Y.Scale, frameStart.Y.Offset + delta.Y
                )
            end
        end)
        
        UserInputService.InputEnded:Connect(function(endInput)
            if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                connection:Disconnect()
            end
        end)
    end
end)

CloseButton.MouseButton1Click:Connect(toggleGUI)

-- Top Right Toggle Button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 40, 0, 40)
ToggleButton.Position = UDim2.new(1, -50, 0, 10)
ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
ToggleButton.BackgroundTransparency = 0.1
ToggleButton.Text = "⚙"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.TextSize = 20
ToggleButton.Parent = ScreenGui

ToggleButton.MouseButton1Click:Connect(toggleGUI)

-- Insert key to toggle GUI
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.Insert then
        toggleGUI()
    end
end)

-- Start the main loop
isRunning = true
spawn(function()
    while isRunning do
        mainLoop()
        wait(0.03)
    end
end)

-- Cleanup
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        isRunning = false
        resetAllHeadScales()
        ScreenGui:Destroy()
    end
end)

print("==========================================")
print("Whizzbang Script - UPDATED AUTO GRENADE THROWING")
print("==========================================")
print("Press INSERT to open/close GUI")
print("Enhanced Auto Throw Grenade Features:")
print("1. Cleans inventory automatically (keeps only 'mill' grenades)")
print("2. Improved aiming: Throws 5 studs above enemy head for better arc")
print("3. Faster throwing: 0.1s equip/throw delay for instant spamming")
print("4. Continuous loop: Get grenade → Throw → Clean → Repeat")
print("==========================================")
print("Class-Specific Inventory Management:")
print("- Rifleman: Keeps ONLY 'mill' item (grenades)")
print("- Engineer: Keeps ONLY 'wire spool' item")
print("- Other classes: No inventory cleanup")
print("==========================================")
print("Features:")
print("- Mini Health ESP (40x12 pixels)")
print("- Hitbox All Enemies toggle")
print("- Auto Cook with 0.3s delay")
print("- Aimbot with FOV, smoothness, and distance controls")
print("==========================================")
